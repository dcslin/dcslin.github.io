{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coding","text":""},{"location":"#_1","title":"\u5bf9\u6570\u5206\u5e03","text":"<p>\u53d8\u5316\u4ee5\u5f53\u524d\u4e58\u4ee5\u4e00\u4e2a\u7cfb\u6570\u4f53\u73b0\u7684\u6570\u636e\u901a\u5e38\u670d\u4ece\u5bf9\u6570\u5206\u5e03\u3002\u4f8b\u5982\uff0c\\(x_1 = x_0 \\times k\\)\uff0c\\(x_2 = x_1 \\times k\\)\uff0c\u5982\u80a1\u4ef7\u7b49\u3002</p>"},{"location":"#_2","title":"\u4e2d\u5fc3\u6781\u9650\u539f\u7406/\u5927\u6570\u5b9a\u7406","text":""},{"location":"#normal","title":"normal\u5206\u5e03","text":"<p>\u6bcf\u4e00\u6b21\u90fd\u662f\u72ec\u7acb\u968f\u673a\u62bd\u53d6\uff0c\u4e0d\u65ad\u7d2f\u79ef\u7684\u548c</p>"},{"location":"#_3","title":"\u7279\u5f81\u5411\u91cf","text":"<p>\u5f20\u6210\u7a7a\u95f4\uff0c\u7ef4\u6570\uff0c\u7ebf\u6027\u6620\u5c04\uff0c\u96f6\u7a7a\u95f4\uff0c\u591a\u9879\u5f0f\uff0c\u7279\u5f81\u503c\uff0c\u7279\u5f81\u5411\u91cf\uff0c\u5185\u79ef\uff0c</p>"},{"location":"#vc","title":"VC\u7ef4","text":""},{"location":"#_4","title":"\u6ca1\u6709\u514d\u8d39\u5348\u9910\u5b9a\u7406","text":""},{"location":"#pac-boosting-em","title":"pac \u5b9a\u7406, boosting, \u6b63\u5219\u5316\uff0c\u5728\u7ebf\u5b66\u4e60\uff0c\u751f\u6210\u6a21\u578b\uff0c\u9690\u53d8\u91cf\uff0cEM\u7b97\u6cd5\uff0c\u8d1d\u53f6\u65af\u63a8\u7406\uff0c","text":""},{"location":"#_5","title":"\u7ebf\u6027\u56de\u5f52","text":"<p>\u7ebf\u6027\u56de\u5f52\u7684\u76ee\u6807\u662f\u627e\u5230\u4e00\u6761\u6700\u80fd\u8868\u8fbe\u6837\u672c\u6570\u636e\u7684\u76f4\u7ebf\uff0c\u901a\u5e38\u5f62\u5f0f\u4e3a \\(y = wx\\)\u3002\u6211\u4eec\u5b9a\u4e49\u635f\u5931\u51fd\u6570\u4e3a\uff1a</p> \\[ \\text{loss} = \\sum (y_i - y)^2 \\] <p>\u901a\u8fc7\u6700\u5c0f\u5316\u635f\u5931\u51fd\u6570\uff08\u5373 \\(\\min(\\text{loss})\\)\uff09\uff0c\u53ef\u4ee5\u6c42\u5f97\u6700\u4f18\u53c2\u6570 \\(w\\)\u3002</p>"},{"location":"#_6","title":"\u6781\u5927\u4f3c\u7136\u4f30\u8ba1","text":"<p>\u5047\u8bbe\u6bcf\u4e2a\u6570\u636e\u70b9\u90fd\u662f\u4ece\u4e00\u4e2a\u9ad8\u65af\u5206\u5e03\u4e2d\u62bd\u53d6\u51fa\u6765\u7684\u3002\u6240\u6709\u70b9\u7684\u6982\u7387\u8fde\u4e58\u79ef\u8d8a\u5927\uff0c\u8bf4\u660e\u8fd9\u7ec4\u53c2\u6570\u8d8a\u80fd\u4ee3\u8868\u6570\u636e\u3002\u5bf9\u4e8e\u7ebf\u6027\u56de\u5f52\uff0c\u5047\u8bbe\u6bcf\u4e2a\u6837\u672c\u7684 \\(y\\) \u90fd\u4f9d\u8d56\u4e8e \\(wx\\)\uff0c\u5373 \\(y\\) \u7684\u6982\u7387\u5206\u5e03\u4e3a \\(N(y|wx, \\sigma^2)\\)\u3002\u5c06\u5176\u4ee3\u5165\u6781\u5927\u4f3c\u7136\u4f30\u8ba1\u540e\uff0c\u53ef\u4ee5\u5316\u7b80\u4e3a\u4e0e\u6b8b\u5dee\u5e73\u65b9\u548c\u76f8\u540c\u7684\u5f62\u5f0f\u3002</p>"},{"location":"#_7","title":"\u91c7\u6837\u4e0e\u4f30\u8ba1","text":"<ul> <li>\u91c7\u6837\uff08Sampling\uff09\uff1a\u4ece\u6982\u7387\u5206\u5e03\u4e2d\u62bd\u53d6\u6837\u672c\uff0c\u5373\u5df2\u77e5\u6982\u7387\u5206\u5e03\uff0c\u751f\u6210\u6570\u636e\u3002</li> <li>\u4f30\u8ba1\uff08Estimation\uff09\uff1a\u6839\u636e\u5df2\u6709\u6837\u672c\u6570\u636e\uff0c\u53cd\u63a8\u51fa\u6982\u7387\u5206\u5e03\u53c2\u6570\uff0c\u5373\u901a\u8fc7\u6570\u636e\u63a8\u65ad\u5206\u5e03\u3002</li> </ul> <p>\u91c7\u6837\u548c\u4f30\u8ba1\u662f\u76f8\u53cd\u7684\u8fc7\u7a0b\u3002\u6982\u7387\uff08Probability\uff09\u7528\u4e8e\u5df2\u77e5\u5206\u5e03\u6c42\u6837\u672c\u7684\u53ef\u80fd\u6027\uff0c\u4f3c\u7136\uff08Likelihood\uff09\u7528\u4e8e\u5df2\u77e5\u6837\u672c\u4f30\u8ba1\u5206\u5e03\u53c2\u6570\uff0c\u4e24\u8005\u4e5f\u662f\u9006\u5411\u5173\u7cfb\u3002</p>"},{"location":"#svm","title":"SVM","text":""},{"location":"#pca","title":"PCA","text":""},{"location":"#kl-divergent","title":"KL divergent","text":"<p>clique\u56e2\uff0c \u8d1d\u53f6\u65af\u7f51\u7edc\uff0c\u9a6c\u5c14\u53ef\u592b\u94fe\uff0c \u63a8\u65adinterfence\uff0c \u7cbe\u786e\u63a8\u65ad\uff1a\u53d8\u91cf\u6d88\u9664\uff0c\u56e2\u6811\u7b97\u6cd5\uff0c\u4fe1\u5ff5\u4f20\u64ad \u8fd1\u4f3c\u63a8\u65ad\uff1a\u8499\u7279\u5361\u6d1b\uff0cmcmc\uff0c\u53d8\u5206\u63a8\u65ad\uff0c\u7f6e\u4fe1\u4f20\u64ad \u5b66\u4e60learning \u53c2\u6570\u5b66\u4e60\uff1a\u6781\u5927\u4f3c\u7136\uff0c\u8d1d\u53f6\u65af\u53c2\u6570\uff0cem\u7b97\u6cd5 \u7ed3\u6784\u5b66\u4e60 \u6761\u4ef6\u72ec\u7acb\u6027\u68c0\u9a8c \u62d3\u5c55\u6a21\u578b\uff1a\u9690\u9a6c\u5c14\u53ef\u592b\u94fe\uff0c\u6761\u4ef6\u968f\u673a\u573a\uff0c\u56e0\u5b50\u56fe\uff0cGAN</p>"},{"location":"asyncio/","title":"Asyncio","text":"<p>async func could be await-ed in jupyter lab directly:</p> <pre><code>import asyncio\nimport websockets\nimport datetime\n\nasync def attach(uri, n=5):\n    data = []\n    async with websockets.connect(uri) as ws:\n        for i in range(n):\n            recv = await ws.recv()\n            print(recv)\n            data.append(recv)\n    return data\n\ndata = await attach(endpoint)\nlen(data)\n</code></pre> <p>alternative concurrent.Futures</p>"},{"location":"debian/","title":"Debian","text":"<p>Debian services</p> <ul> <li>systemctl</li> <li>journalctl</li> </ul> <p>systemctl manages services</p> <pre><code>sudo systemctl reboot\nsudo systemctl shutdown\n</code></pre> <p>view log ssh </p> <p><code>journalctl -t sshd</code></p> <p>k8s:</p> <p>minikube, kind are cluster managers.</p>"},{"location":"my-git/","title":"My git","text":"<p>no-reply github email:</p> <p>dcslin@users.noreply.github.com</p>"},{"location":"rust/","title":"Rust lang","text":""},{"location":"rust/#basic-syntax","title":"Basic Syntax","text":"<pre><code>fn main() {\n    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n\n    let mut x = 5;\n    println!(\"x is {x}\");\n    x = 6;\n    println!(\"x is {x}\");\n\n    let guess:u32 = \"42\".parse().expect(\"failed to parse\")\n\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n\n    let a = [1, 2, 3, 4, 5];\n\n    let a: [i32; 5] = [1, 2, 3, 4, 5];\n\n    let a = [3; 5];\n\n    if number &lt; 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n\n    let number = if condition { 5 } else { 6 };\n\n    loop {\n        println!(\"again!\");\n        break;\n    }\n\n    while number != 0 {\n        println!(\"{number}!\");\n\n        number -= 1;\n    }\n\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(\"the value is: {element}\");\n    }\n\n    for number in (1..4).rev() {\n        println!(\"{number}!\");\n    }\n    println!(\"LIFTOFF!!!\");\n}\n\nfn another_function(x: i32) {\n    println!(\"The value of x is: {x}\");\n}\n\nfn five() -&gt; i32 {\n    5\n}\n\n</code></pre>"},{"location":"rust/#primitive-types-collections","title":"Primitive Types, Collections","text":"<p>string, tuple, vector</p> <pre><code>let s = \"hello\";\n\nlet s = String::from(\"hello\");\n</code></pre> <p><code>String</code> vs <code>\"..\"</code> vs <code>str</code></p> <p><code>&amp;str</code> is <code>&amp;s[..]</code> string slice. <code>String</code> is string object.  <code>\"..\"</code> is string literal.</p>"},{"location":"rust/#unique-concepts","title":"Unique Concepts","text":"<p>Ownership, Reference, borrowing, pattern matching, Stack and Heap, Result and Panic, Traits, Lifetimes, smart pointers</p> <p>Move </p> <pre><code>    let x = 5;\n    let y = x;\n\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n</code></pre> <pre><code>fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into\n    a_string  // a_string is returned and moves out to the calling function\n}\n</code></pre> <p>Reference/borrowing</p> <pre><code>fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&amp;s1);\n\n    println!(\"The length of '{s1}' is {len}.\");\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n}\n\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&amp;mut s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(\", world\");\n}\n</code></pre> <p>slice Reference</p> <pre><code>    let s = String::from(\"hello world\");\n\n    let hello = &amp;s[0..5];\n    let world = &amp;s[6..11];\n</code></pre> <p>Slice ref type, <code>&amp;[i32]</code></p> <p>enum</p> <pre><code>    enum IpAddrKind {\n        V4,\n        V6,\n    }\n\n    struct IpAddr {\n        kind: IpAddrKind,\n        address: String,\n    }\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n</code></pre> <p>match</p> <pre><code>enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\nfn main(){\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            None =&gt; None,\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n}\n</code></pre> <pre><code>    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"State quarter from {state:?}!\");\n    } else {\n        count += 1;\n    }\n</code></pre> <p>Result</p> <pre><code>use std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; panic!(\"Problem opening the file: {error:?}\"),\n    };\n}\n</code></pre> <p>return result error directly</p> <pre><code>use std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&amp;mut username)?;\n    Ok(username)\n}\n</code></pre>"},{"location":"rust/#other-core-concepts","title":"Other Core Concepts","text":"<p>Generics, enum, Closures, Iterators, struct, threading, oop</p> <p>struct</p> <pre><code>#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n\n</code></pre>"},{"location":"rust/#build-tools","title":"Build Tools","text":"<p>Cargo, workspace, project structure, tests</p> <pre><code>cargo new project0\n\ncargo build\n\ncargo run\n\n\n</code></pre> <p>workspace</p> <p>Filename: Cargo.toml</p> <pre><code>[workspace]\n\nmembers = [\n    \"adder\",\n    \"add_one\",\n]\n</code></pre> <pre><code>cargo new adder\n\ncargo new add_one --lib\n</code></pre> <p>Filename: adder/Cargo.toml</p> <pre><code>[dependencies]\nadd_one = { path = \"../add_one\" }\n</code></pre>"},{"location":"rust/#tests","title":"Tests","text":"<pre><code>pub fn add(left: usize, right: usize) -&gt; usize {\n    left + right\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        let result = add(2, 2);\n        assert_eq!(result, 4);\n    }\n}\n</code></pre>"}]}